# 第八章 选择合适的数据类型

## CHAR和VARCHAR

+ 在MySQL中，不同的存储引擎对char和varchar的使用原则有所不同：
    1. MySQL：建议使用固定长度的数据列代替可变长度的数据列
    2. MyISAM：目前都使用固定长度的数据行存储，因此无论使用 CHAR 或VARCHAR 列都没有关系。**两者都是作为CHAR类型处理**
    3. InnoDB：建议使用 VARCHAR 类型

## TEXT和BLOB

+ 特点：
    >类型|特性|包含类型|使用场景
    >|:-|:---|:------|:-----|
    >text|保存较大文本|text</br>mediumtext</br>longtext|比如一篇文章或者日记
    >blob|能用来保存二进制数据|blob</br>mediumtext</br>longtext|照片等
+ 性能问题
    1. 在执行了大量的删除操作时，数据表会留下很多碎片
    2. 为了提高性能，应该定期使用`optimize table`对碎片进行整理
+ 可以使用合成的（Synthetic）索引来提高大文本字段（BLOB或TEXT）的查询功能
    1. 简单来说，合成索引就是根据大文本字段的内容建立一个 **散列值**，并把这个值存储在单独的数据列中，接下来就可以通过检索散列值找到数据行了
    2. 生成散列值的函数：`md5()`、`sha1()`或`crc32()`，也可以使用自己的应用程序逻辑来计算散列值
    3. 合成索引的使用方法：
        1. 使用字段来存储md5()散列值，例如：`INSERT INTO t (1, REPEAT('beijing', 2), MD5(context);`
        2. 使用散列值来查询记录，例如：`SELECT * FROM t WHERE hash_value = MD5(REPEAT('beijing', 2));`
    4. 合成索引的技术只能用于 **精确匹配**，在一定程度上减少I/O，从而 **提高查询效率**
+ 对BLOB和CLOB字段支持的 **模糊查询**：
    1. 前缀索引：也就是只为字段的前n列创建索引，例如：

        ```sql
        CREATE INDEX idx_blob ON t (context(100));
        DESC SELECT * FROM t WHERE context LIKE 'beijing%' \G;
        ```

        可以对context前100个字符进行模糊查询</br>
        **注意**，这里的查询的条件中，`%`不能放在最前面，否则索引将不会被使用
    2. 在不必要的时候避免检索大型的BLOB或TEXT值
    3. 把BLOB或TEXT列分离到单独的表中

## 浮点数和定点数

+ 如果插入数据的精度超过该列定义的实际精度，被插入值会被四舍五入到实际定义的精度值
+ 定点数实际上是以字符串的形式存放的，定点数可以更加精确的保存数据
+ 在编程中尽量避免浮点数的比较，如果非要使用浮点数比较则最好使用范围比较而不要使用“==”比较
+ 使用两种变量时应该注意的几点原则：
    1. 浮点数存在误差
    2. 对货币等对精度敏感的数据，应该使用定点数
    3. 要注意浮点数中一些特殊值的处理
