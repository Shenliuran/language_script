# 线程安全

## 线程安全性

+ 线程安全的类：
    1. 当多个线程访问这个类时，不用考虑这些线程在运行时环境下的调度和交替变化
    2. 不需要额外的同步
    3. 在代码调用方面不用做其他的协调
+ 程序的安全性：任何单线程化的程序同时也是合法的多线程化程序
+ 无状态的对象永远时线程安全的（无状态对象：对象没有成员变量）
+ 有状态的对象才会出现线程安全问题（有状态对象：对象有成员变量）

## 原子性

+ 要注意，惰性初始换，会造成线程安全问题（惰性初始化：在对象需要使用时才初始化）
+ 在设计多线程程序时，要仔细考虑操作的原子性

## 锁

### 内部锁

+ `synchronized`块：
    1. 锁对象的引用
    2. 锁保护的代码块
+ synchronized方法的锁，来自方法所在对象本身的锁
+ 静态的synchronized方法的锁，来自Class对象
+ 每一个Java对象都可以隐式地扮演一个用于同步的锁的对象
+ 执行线程进入synchronized块之前会自动获得锁
+ 无论通过何种方式退出synchronized块，线程都会自动释放锁
+ 获取内部锁的唯一途径就是：进入这个内部锁保护的同步块或方法
+ 内部锁在Java中是一种互斥锁，意味着最多只能有一个线程可以拥有锁
+ 由同一个锁保护的synchronized块会各自原子地执行，互不干扰

### 重进入

+ 可重进入意味着，线程在试图获得它自己占有的锁时，请求会成功
+ 请求是基于“每线程”，而不是基于“每调用”
+ 使用计数器实现

## 用锁来保护状态

+ 锁使得线程能够串行地（serialized）访问它所保护的代码路径
+ 可以用锁来创建相关的协议

## 活跃度和性能

+ 决定`synchronized`块的大小需要权衡各种设计要求：
    1. 安全性（不能妥协）
    2. 简单性
    3. 性能
+ 通常简单性与性能之间是相互牵扯的，实现一个同步策略时，不要过早的为了性能而牺牲简单性
+ 在使用锁的时候，应该清楚代码块中的功能，以及它的执行过程是否会很耗时
+ 有些耗时的计算或操作，如网络或者控制台I/O，难以快速完成，**执行这些操作期间不要占用锁**（会带来性能风险）
